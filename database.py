import hashlib
import os

import streamlit as st
from passlib.hash import pbkdf2_sha256
import psycopg
from supabase import create_client


CATEGORIAS_PADRAO = [
    "Geral",
    "Vendas",
    "Marketing",
    "Financeiro",
    "RH",
    "Operacoes",
    "Logistica",
    "Suprimentos",
    "Operacional",
]


class Database:
    def __init__(self):
        self.supabase = self._create_client()
        self.init_database()

    def _get_secret(self, key: str, default: str = "") -> str:
        if key in st.secrets:
            return str(st.secrets[key])
        return os.getenv(key, default)

    def _create_client(self):
        url = self._get_secret("SUPABASE_URL")
        key = self._get_secret("SUPABASE_KEY")
        if not url or not key:
            raise RuntimeError("SUPABASE_URL e SUPABASE_KEY sao obrigatorios.")
        return create_client(url, key)

    def _create_schema_if_needed(self):
        db_url = self._get_secret("SUPABASE_DB_URL")
        if not db_url:
            raise RuntimeError(
                "Schema ausente no Supabase e SUPABASE_DB_URL nao foi definido para criacao automatica."
            )

        schema_sql = """
        create table if not exists public.usuarios (
            id bigint generated by default as identity primary key,
            username text unique not null,
            email text unique,
            password_hash text not null,
            is_admin boolean not null default false,
            ativo boolean not null default true,
            categorias_permitidas jsonb not null default '[]'::jsonb,
            criado_em timestamptz not null default now()
        );

        create table if not exists public.relatorios (
            id bigint generated by default as identity primary key,
            titulo text not null,
            link_powerbi text not null,
            descricao text,
            categoria text not null default 'Geral',
            tags text,
            criado_por bigint references public.usuarios(id) on delete set null,
            ativo boolean not null default true,
            criado_em timestamptz not null default now(),
            atualizado_em timestamptz not null default now()
        );

        create table if not exists public.logs_acesso (
            id bigint generated by default as identity primary key,
            usuario_id bigint references public.usuarios(id) on delete set null,
            relatorio_id bigint references public.relatorios(id) on delete set null,
            data_acesso timestamptz not null default now()
        );

        create index if not exists idx_relatorios_categoria on public.relatorios(categoria);
        create index if not exists idx_relatorios_criado_por on public.relatorios(criado_por);
        create index if not exists idx_usuarios_username on public.usuarios(username);

        create or replace function public.set_relatorio_updated_at()
        returns trigger
        language plpgsql
        as $$
        begin
            new.atualizado_em = now();
            return new;
        end;
        $$;

        drop trigger if exists trg_relatorios_updated_at on public.relatorios;
        create trigger trg_relatorios_updated_at
        before update on public.relatorios
        for each row
        execute function public.set_relatorio_updated_at();

        alter table public.usuarios disable row level security;
        alter table public.relatorios disable row level security;
        """

        with psycopg.connect(db_url, autocommit=True) as conn:
            with conn.cursor() as cur:
                cur.execute(schema_sql)

    def hash_password(self, password: str) -> str:
        return pbkdf2_sha256.hash(password)

    @staticmethod
    def _legacy_hash_password(password: str) -> str:
        # Compatibilidade com hashes antigos (sha256 + salt fixo).
        return hashlib.sha256(f"{password}_salt_grupofrt".encode()).hexdigest()

    @staticmethod
    def _parse_categorias(value, is_admin=False):
        if isinstance(value, list):
            return value
        if not value:
            return CATEGORIAS_PADRAO if is_admin else []
        return CATEGORIAS_PADRAO if is_admin else []

    def _verify_password(self, password: str, stored_hash: str):
        # Tenta verificar hash moderno (pbkdf2_sha256).
        try:
            if stored_hash and stored_hash.startswith("$pbkdf2-sha256$"):
                return pbkdf2_sha256.verify(password, stored_hash), False
        except Exception:
            pass

        # Fallback para hash legado.
        if self._legacy_hash_password(password) == stored_hash:
            return True, True

        return False, False

    def init_database(self):
        try:
            self.supabase.table("usuarios").select("id").limit(1).execute()
            self.supabase.table("relatorios").select("id").limit(1).execute()
        except Exception:
            self._create_schema_if_needed()
            self.supabase.table("usuarios").select("id").limit(1).execute()
            self.supabase.table("relatorios").select("id").limit(1).execute()

        admin = (
            self.supabase.table("usuarios")
            .select("id")
            .eq("username", "admin")
            .limit(1)
            .execute()
        )
        if not admin.data:
            initial_admin_password = self._get_secret("ADMIN_INITIAL_PASSWORD")
            if not initial_admin_password:
                raise RuntimeError(
                    "Usuario admin nao existe e ADMIN_INITIAL_PASSWORD nao foi definido."
                )
            self.supabase.table("usuarios").insert(
                {
                    "username": "admin",
                    "password_hash": self.hash_password(initial_admin_password),
                    "is_admin": True,
                    "categorias_permitidas": CATEGORIAS_PADRAO,
                }
            ).execute()

        users = self.supabase.table("usuarios").select("id,is_admin,categorias_permitidas").execute()
        for user in users.data or []:
            if not user.get("categorias_permitidas"):
                default_categorias = CATEGORIAS_PADRAO if user.get("is_admin") else ["Geral"]
                (
                    self.supabase.table("usuarios")
                    .update({"categorias_permitidas": default_categorias})
                    .eq("id", user["id"])
                    .execute()
                )

    def autenticar_usuario(self, username: str, password: str):
        resp = (
            self.supabase.table("usuarios")
            .select("id,username,password_hash,is_admin,categorias_permitidas")
            .eq("username", username)
            .limit(1)
            .execute()
        )
        if not resp.data:
            return None

        usuario = resp.data[0]
        password_ok, needs_rehash = self._verify_password(password, usuario["password_hash"])
        if not password_ok:
            return None

        if needs_rehash:
            (
                self.supabase.table("usuarios")
                .update({"password_hash": self.hash_password(password)})
                .eq("id", usuario["id"])
                .execute()
            )

        return {
            "id": usuario["id"],
            "username": usuario["username"],
            "is_admin": bool(usuario.get("is_admin", False)),
            "categorias_permitidas": self._parse_categorias(
                usuario.get("categorias_permitidas"), bool(usuario.get("is_admin", False))
            ),
            "autenticado": True,
        }

    def _usuarios_map_por_id(self):
        resp = self.supabase.table("usuarios").select("id,username").execute()
        return {u["id"]: u["username"] for u in (resp.data or [])}

    def listar_relatorios_usuario(self, usuario):
        query = (
            self.supabase.table("relatorios")
            .select("id,titulo,link_powerbi,descricao,categoria,criado_por,criado_em,atualizado_em")
            .order("criado_em", desc=True)
        )
        if not usuario["is_admin"] and usuario["categorias_permitidas"]:
            query = query.in_("categoria", usuario["categorias_permitidas"])

        resp = query.execute()
        user_map = self._usuarios_map_por_id()
        relatorios = []
        for r in resp.data or []:
            relatorios.append(
                {
                    "id": r["id"],
                    "titulo": r["titulo"],
                    "link_powerbi": r["link_powerbi"],
                    "descricao": r.get("descricao"),
                    "categoria": r.get("categoria") or "Geral",
                    "criado_por": r.get("criado_por"),
                    "criado_em": r.get("criado_em"),
                    "atualizado_em": r.get("atualizado_em") or r.get("criado_em"),
                    "criador": user_map.get(r.get("criado_por"), "Sistema"),
                }
            )
        return relatorios

    def obter_relatorio_por_id(self, relatorio_id: int):
        resp = (
            self.supabase.table("relatorios")
            .select("id,titulo,link_powerbi,descricao,categoria,criado_por,criado_em,atualizado_em")
            .eq("id", relatorio_id)
            .limit(1)
            .execute()
        )
        if not resp.data:
            return None
        r = resp.data[0]
        user_map = self._usuarios_map_por_id()
        return {
            "id": r["id"],
            "titulo": r["titulo"],
            "link_powerbi": r["link_powerbi"],
            "descricao": r.get("descricao"),
            "categoria": r.get("categoria") or "Geral",
            "criado_por": r.get("criado_por"),
            "criado_em": r.get("criado_em"),
            "atualizado_em": r.get("atualizado_em") or r.get("criado_em"),
            "criador": user_map.get(r.get("criado_por"), "Sistema"),
        }

    def criar_relatorio(self, titulo, link_powerbi, descricao, categoria, criado_por):
        self.supabase.table("relatorios").insert(
            {
                "titulo": titulo,
                "link_powerbi": link_powerbi,
                "descricao": descricao,
                "categoria": categoria,
                "criado_por": criado_por,
            }
        ).execute()
        return True

    def atualizar_relatorio(self, relatorio_id, titulo, link_powerbi, descricao, categoria):
        (
            self.supabase.table("relatorios")
            .update(
                {
                    "titulo": titulo,
                    "link_powerbi": link_powerbi,
                    "descricao": descricao,
                    "categoria": categoria,
                }
            )
            .eq("id", relatorio_id)
            .execute()
        )
        return True

    def excluir_relatorio(self, relatorio_id):
        self.supabase.table("relatorios").delete().eq("id", relatorio_id).execute()
        return True

    def listar_usuarios(self):
        resp = (
            self.supabase.table("usuarios")
            .select("id,username,is_admin,categorias_permitidas,criado_em")
            .order("criado_em", desc=True)
            .execute()
        )
        usuarios = []
        for u in resp.data or []:
            usuarios.append(
                {
                    "id": u["id"],
                    "username": u["username"],
                    "is_admin": bool(u.get("is_admin", False)),
                    "categorias_permitidas": self._parse_categorias(
                        u.get("categorias_permitidas"), bool(u.get("is_admin", False))
                    ),
                    "criado_em": u.get("criado_em"),
                }
            )
        return usuarios

    def obter_usuario_por_id(self, usuario_id):
        resp = (
            self.supabase.table("usuarios")
            .select("id,username,is_admin,categorias_permitidas")
            .eq("id", usuario_id)
            .limit(1)
            .execute()
        )
        if not resp.data:
            return None
        u = resp.data[0]
        return {
            "id": u["id"],
            "username": u["username"],
            "is_admin": bool(u.get("is_admin", False)),
            "categorias_permitidas": self._parse_categorias(
                u.get("categorias_permitidas"), bool(u.get("is_admin", False))
            ),
        }

    def criar_usuario_portal(self, username, senha, is_admin=False, categorias_permitidas=None):
        if categorias_permitidas is None:
            categorias_permitidas = CATEGORIAS_PADRAO if is_admin else ["Geral"]
        self.supabase.table("usuarios").insert(
            {
                "username": username,
                "password_hash": self.hash_password(senha),
                "is_admin": bool(is_admin),
                "categorias_permitidas": categorias_permitidas,
            }
        ).execute()
        return True

    def atualizar_usuario_portal(self, usuario_id, username=None, is_admin=None, categorias_permitidas=None):
        updates = {}
        if username:
            updates["username"] = username
        if is_admin is not None:
            updates["is_admin"] = bool(is_admin)
        if categorias_permitidas is not None:
            updates["categorias_permitidas"] = categorias_permitidas
        if not updates:
            return True
        self.supabase.table("usuarios").update(updates).eq("id", usuario_id).execute()
        return True

    def atualizar_senha_portal(self, usuario_id, nova_senha):
        (
            self.supabase.table("usuarios")
            .update({"password_hash": self.hash_password(nova_senha)})
            .eq("id", usuario_id)
            .execute()
        )
        return True

    def excluir_usuario(self, usuario_id):
        self.supabase.table("usuarios").delete().eq("id", usuario_id).execute()
        return True
